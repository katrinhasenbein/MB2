---
title: "Chapter2"
author: "of the Textbook 'Applied Spatial Data Analysis with R'"
output:
  slidy_presentation: default
  ioslides_presentation: default
  beamer_presentation: default
widescreen: yes
---

```{r, echo = FALSE}
library(knitr)
opts_chunk$set(comment = "") 
setwd("C:/Users/katri/Documents/Uni/Master/MB2 Introduction to Programming and Geostatistics/2017-11-21/")
```



## R as a calculator

```{r}
pi * 10^2
```
  
R is translating calculation into function
```{r}
"*"(pi, "^"(10,2))
```

  
Calculations with vectors
```{r}
pi * (1:5)^2
```

## Printing the result of a calculation

```{r, echo = FALSE}
 x <- pi*10^2
```

```{r}
x
```
Or:
```{r}
print(x)
```
Or if you want to define the number of digits: 
```{r}
print(x, digits = 12)
```

##Classes of objects
Check class and storage mode:
```{r, eval = FALSE}
class(x); typeof(x)
```

--> determines how object is treated by functions

## Example dataset *cars*
```{r}
class(cars); typeof(cars)
```
***
object data.frame has names and summary methods:
```{r}
names(cars)
```
```{r}
summary(cars)
```

## Further methods to get an insight on structure of objects
- ls(): list contents of workspace
- str(): structure of object (size, class)

## Dataframes
- containers for data
- rows: observations
- columns: variables of interest
- can include all types of objects

## Formula
response variable ~ determining variable
```{r}
class(dist~speed)
```
--> formula typically used to fit linear models
```{r}
lm(dist~speed, data = cars)
```
***
```{r, echo = FALSE}
mod1 <- lm(dist~speed, data = cars)
plot(cars$speed, cars$dist)
abline(mod1$coefficients[1], mod1$coefficients[2])
```


## Creating a factor
```{r}
cars$qspeed <-  cut(cars$speed, breaks = quantile(cars$speed), 
                    include.lowest = TRUE)
```
```{r, echo = FALSE}
par(mfrow=c(1,2))
plot(dist ~ speed, data = cars, main = "scatterplot")
plot(dist ~ qspeed, data = cars, main = "boxplot")
```


##Spatial Objects
```{r}
library(sp)
#get complete definition of class (with subclasses)
getClass("Spatial")
```

## CRS (coordinate reference system) class
```{r, echo = FALSE}
getClass("CRS")
```
--> character string describing projection  

***  
Building a spatial object
```{r}
#bounding box
m <- matrix(c(0,0,1,1), ncol = 2, dimnames = list(NULL, c("min", "max")))
#missing coordinate system
crs <- CRS(projargs = as.character(NA))
```
```{r}
S <- Spatial(bbox = m, proj4string = crs)
S
```

##
R checks coordinate range
```{r}
bb <-  matrix(c(350,85,370,95), ncol = 2, dimnames = list(NULL, c("min", "max")))
Spatial(bb, proj4string = CRS("+proj=longlat"))
```
--> Should show Error: "Geographical CRS given to non-conformat data"

##Spatial Points
defined by a pair of numbers (=coords)
```{r, echo = FALSE}
getClass("SpatialPoints")
```

## Example: spatial points of CRAN mirrors

```{r}
CRAN_df <-  read.table("CRAN051001a.txt", header = TRUE)
CRAN_mat <- cbind(CRAN_df$long, CRAN_df$lat)
row.names(CRAN_mat) <- 1:nrow(CRAN_mat)
```
  
Converting matrix into Spatial Points
```{r}
llCRS <- CRS("+proj=longlat + ellps=WGS84")
CRAN_sp <- SpatialPoints(CRAN_mat, proj4string = llCRS)
```
##
```{r}
summary(CRAN_sp)
```

##Methods and functions for SpatialPoints
- bbox(): bounding box of object
    + first row: west-east range
    + second row: south-north range
- proj4string(): projection string
- coordinates(): extracting coordinates

***  
Example: extract CRAN mirrors in Brazil
```{r}
brazil <- which(CRAN_df$loc == "Brazil"); brazil
coordinates(CRAN_sp)[brazil,]
```
###Indexing of Spatial Points
--> works the same as for data.frames/vectors/...

##Data Frames for SpatialPoints Data
```{r}
getClass("SpatialPointsDataFrame")
```

## Characteristics of SpatialPointsDataFrames
- data: data.frame
- SpatialPoints
    + coords
    + spatial information: bbox, proj4string
- coords.nrs
  
--> designed to behave as fas as possible like data frames  
--> standard methods for data.frames work as well

***
```{r, echo = FALSE}
CRAN_spdf1 <-  SpatialPointsDataFrame(CRAN_mat, CRAN_df, proj4string = llCRS, match.ID = TRUE)
```

```{r}
head(CRAN_spdf1)

````

***
```{r}
names(CRAN_spdf1)
str(model.frame(lat ~long, data = CRAN_spdf1), give.attr = FALSE)
```


##Creating a SpatialPointsDataFrame
- associating correct row of data frame with their point coordinates
```{r}
#SpatialPointsDataFrame needs two indices: spatial object and column
CRAN_spdf1 <- SpatialPointsDataFrame(CRAN_mat, CRAN_df, proj4string = llCRS, 
                                     match.ID = TRUE)
CRAN_spdf1[4,]
```
--> requirements:  
- data and matrix of coords have matching row names  
- match.ID = TRUE

## 
same result if data.frame is re-ordered randomly
```{r}
s <-  sample(nrow(CRAN_df))
CRAN_spdf2 <-  SpatialPointsDataFrame(CRAN_mat, CRAN_df[s,], proj4string = llCRS, 
                                      match.ID = TRUE)
all.equal(CRAN_spdf2, CRAN_spdf1)
```

## Alternative ways
- giving SpatialPointsDataFrame function SpatialPoints object as its first argument
```{r}
CRAN_spdf4 <-  SpatialPointsDataFrame(CRAN_sp, CRAN_df)
all.equal(CRAN_spdf4, CRAN_spdf2)
```
- assign coordinates to a data frame
```{r}
CRAN_df0 <-  CRAN_df
coordinates(CRAN_df0) <-  CRAN_mat
proj4string(CRAN_df0) <-  llCRS
all.equal(CRAN_df0, CRAN_spdf2)
```
  --> modifies original data frame!

##Another dataset: tracking data of a turtle
```{r}
turtle_df <- read.csv("seamap105_mod.csv")
summary(turtle_df)
```

***
###Preprocessing of the data: Re-order input data frame by timestamp
```{r}
timestamp <- as.POSIXlt(strptime(as.character(turtle_df$obs_date), "%m/%d/%Y %H:%M:%S"), 
                        "GMT")
turtle_df1 <- data.frame(turtle_df, timestamp = timestamp)
turtle_df1$lon <- ifelse(turtle_df1$lon < 0, turtle_df1$lon + 360, turtle_df1$lon)
turtle_sp <- turtle_df1[order(turtle_df1$timestamp),]
coordinates(turtle_sp) <- c("lon", "lat")
proj4string(turtle_sp) <- CRS("+proj=longlat +ellps=WGS84")
```
```{r, echo = FALSE}
plot(turtle_sp)
```


##SpatialLines
```{r}
getClass("Line")
```
list of **Line** objects forms **Lines** slot

##
```{r}
getClass("Lines")
```
##
**SpatialLines** object contains spatial information
```{r}
getClass("SpatialLines")
```

--> summary: Line -> Lines -> SpatialLines

##Example of a Spatial Line Object
```{r}
library(maps)
japan <-  map("world", "japan", plot = FALSE)
p4s <- CRS("+proj=longlat +ellps=WGS84")
library(maptools)
#conversion to SpatialLines by using map2SpatialLines function in maptools
SLjapan <- map2SpatialLines(japan, proj4string =p4s)
str(SLjapan, max.level = 2)
```

##Characteristics of SpatialLines
- lines
    + Line: coords
    + ID
- spatial information: bbox, proj4string

## Converting SpatialLines into SpatialLinesDataFrame
--> ContourLines2SLDF function of maptools package
```{r}
volcano_sl <- ContourLines2SLDF(contourLines(volcano))
t(slot(volcano_sl, "data"))
```
--> ten separate contour level labels

##Another example: shoreline data (Mapgen format) into SpatialLines
```{r}
llCRS <- CRS("+proj=longlat +ellps=WGS84")
auckshore <-  MapGen2SL("auckland_mapgen.dat", llCRS)
summary(auckshore)
```

***
*auckshore* still only SpatialLines
```{r, echo = FALSE}
plot(auckshore)
```
  
--> polygons formed by line rings cannot be filled

##SpatialPolygons
```{r}
lns <- slot(auckshore, "lines")
#length of the Lines slot of each Lines object in the lines list
table(sapply(lns, function(x) length(slot(x,"Lines"))))
```
##
--> checking equality of the first and last coordinates of the first Line object in each Lines object  
```{r}
islands_auck <-  sapply(lns, function(x){
  crds <- slot(slot(x,"Lines")[[1]], "coords")
  identical(crds[1,], crds[nrow(crds),])
})
table(islands_auck)
```

##Class: Polygon
```{r}
getClass("Polygon")
```
- label point: centroid of the polygon
- area
- hole
- ring direction

##Polygons
```{r}
getClass("Polygons")
```
- list of polygon objects
- identifying string
- label point: label point of the polygon with the largest area
- area: sum of all polygons

##SpatialPolygons
```{r}
getClass("SpatialPolygons")
```
- set of Polygons objects
- spatial information: bbox, project information

##Creating a SpatialPolygons object
```{r}
#Chosing only lines in Auckland shoreline data set which are closed polygons
islands_sl <- auckshore[islands_auck]
list_of_Lines <- slot(islands_sl, "lines")
islands_sp <- SpatialPolygons(lapply(list_of_Lines, function(x){Polygons(list(Polygon             
  (slot(slot(x,"Lines")[[1]], "coords"))), ID = slot(x, "ID"))}), proj4string 
  =CRS("+proj=longlat +ellps=WGS84"))
summary(islands_sp)
```
##
```{r, echo = FALSE}
plot(islands_sp, col = "gray")
```

##SpatialPolgyongsDataFrame
--> bring together spatial representations of polygons with data (ID of polygons ~ row number of data.frame)

###Example data: Scholastic Aptitude Test
```{r}
#state boundary polygons provided in maps package
state.map <- map("state", plot = FALSE, fill = TRUE)
IDs <- sapply(strsplit(state.map$names, ":"), function(x) x[1])
state.sp <- map2SpatialPolygons(state.map, IDs = IDs, proj4string = 
  CRS("+proj=longlat + ellps=WGS84"))
```

##
```{r}
#subset to the matched rows of the data frame
sat <- read.table("state.sat.data_mod.txt", row.names = 5, header = TRUE)
str(sat)
```
```{r}
id <- match(row.names(sat), row.names(state.sp))
row.names(sat)[is.na(id)]
```
Caution: R is case-sensitive! "Alaska" != "alaska"

***
```{r}
sat1 <- sat[!is.na(id),]
state.spdf <- SpatialPolygonsDataFrame(state.sp,sat1)
str(state.spdf, max.level = 2)
```

##Drop some polygons
```{r}
#drop District of Columbia
DC <- "district of columbia"
not_dc <- !(row.names(state.spdf) == DC)
state.spdf1 <-  state.spdf[not_dc,]
dim(state.spdf); dim(state.spdf1)
```

##
```{r}
summary(state.spdf1)
```

## Holes and Rings
- GIS: boundaries between polygons only stored once
--> topological representation of polygons
- R: non-topological representation of polygons
--> solution: 
    + logical flag *hole* 
    + ring direction
        * clockwise rings: no holes
        * anti-clockwise rings: holes
      
##Example data: Canadian shore of Lake Huron
```{r}
load("high.RData")
manitoulin_sp <- high[[4]]
length(slot(manitoulin_sp, "polygons"))
```
```{r}
sapply(slot(slot(manitoulin_sp, "polygons")[[1]], "Polygons"), function(x) slot
  (x, "hole"))
```
```{r}
sapply(slot(slot(manitoulin_sp, "polygons")[[1]], "Polygons"), function(x) slot
  (x, "ringDir"))
```

##rgeos packages
--> each hole must be associated with its exterior ring
```{r}
library(rgeos)
manitoulin_sp <- createSPComment(manitoulin_sp)
sapply(slot(manitoulin_sp, "polygons"), comment)
```

##SpatialGrid and SpatialPixel Objects
```{r}
getClass("GridTopology")
```
##Converting vector data into GridTopology
```{r}
bb <- bbox(manitoulin_sp)
bb
```
```{r}
cs <-  c(0.01, 0.01) #defining cell size [°]
cc <-  bb[,1] + (cs/2)
cd <-  ceiling(diff(t(bb))/cs)
manitoulin_grd <-  GridTopology(cellcentre.offset = cc, cellsize = cs, cells.dim = cd)
manitoulin_grd
```

##SpatialGrids
--> GridTopology + spatial information
```{r}
getClass("SpatialGrid")
```

##
```{r}
p4s <- CRS(proj4string(manitoulin_sp))
manitoulin_SG <-SpatialGrid(manitoulin_grd, proj4string = p4s)
summary(manitoulin_SG)
```

***
```{r}
library(raster)
raster1 <-  raster("Auckland SRTM/70042108.tif")
auck_el1 <- as(raster1,"SpatialGridDataFrame")
class(auck_el1)
```

***
```{r}
#GridTopology object
slot(auck_el1, "grid")
```
```{r}
#extent of the SpatialGrid
slot(auck_el1, "bbox")
```

***
```{r}
#total size of SpatialGridDataFrame
object.size(auck_el1)

object.size(slot(auck_el1, "data"))
```
```{r}
#almost half of the data at or below sea level --> set to NA
is.na(auck_el1$BinValues) <- auck_el1$BinValues <= 0
summary(auck_el1$BinValues)
```
--> results in high percentage of missing data

##Another class for spatial grids: SpatialPixels
```{r}
auck_el2 <- as(auck_el1, "SpatialPixelsDataFrame")
object.size(auck_el2)
```
--> several times larger as SpatialGridDataFrame
```{r, echo = FALSE}
#object.size(slot(auck_el2, "grid.index"))
#object.size(slot(auck_el2, "coords"))
#sum(is.na(auck_el1$BinValues)) + #nrow(slot(auck_el2, "coords"))
#(slot(slot(auck_el2, "grid"), "cells.dim"))
# --> numbers should be the same??
```

## Taking only raster cells over 500m
```{r}
auck_el_500_1 <- auck_el2[!is.na(auck_el2$BinValues),]
auck_el_500 <- auck_el_500_1[auck_el_500_1$BinValues > 500,]
```

***
```{r}
summary(auck_el_500@data)
object.size(auck_el_500)
```

##Creating SpatialPixels directly from SpatialPoints
```{r}
data("meuse.grid") #provided with sp
mg_SP <- SpatialPoints(cbind(meuse.grid$x, meuse.grid$y))
summary(mg_SP)
```

***
```{r}
mg_SPix0 <-  SpatialPixels(mg_SP)
summary(mg_SPix0)
```

***
```{r}
prod(slot(slot(mg_SPix0, "grid"), "cells.dim"))
```
--> over half of the grid is not present in SpatialPixels representation (outside of study area)

##Alternatively: Coerce SpatialPoints object to SpatialPixel object
```{r}
mg_SPix1 <- as(mg_SP, "SpatialPixels")
summary(mg_SPix1)
```

## raster package
uses sp classes for vector data and adds new classes and methods for raster data
```{r}
library(raster)
r <-  raster("Auckland SRTM/70042108.tif")
class(r)
```
```{r}
# raster objects can be held on disk rather than in memory
inMemory(r)
```

## Some statistics on raster layers
```{r}
cellStats(r,max);cellStats(r, min)
```

##Remove values of less than or equal to zero
--> in blocks of rows, storing the data ot the new object in a temporary file
```{r}
out <-raster(r)
bs <- blockSize(out)
out <- writeStart(out, filename = tempfile(), overwrite = TRUE)
for (i in 1:bs$n) {
  v <- getValues(r, row = bs$row[i], nrows = bs$nrows[i])
  v[v<=0] <- NA
  writeValues(out, v, bs$row[i])
}
out <- writeStop(out)
cellStats(out, min); cellStats(out, max)
```

##Plot methods of raster
```{r, echo = FALSE}
plot(out, col=terrain.colors(100))
```


## Coercion between classes in sp and raster

```{r}
r1 <- as(out, "SpatialGridDataFrame")
r2 <-  as(r1,"RasterLayer")
```
***
```{r}
summary(r1)
```

***
```{r}

summary(r2) 
```

